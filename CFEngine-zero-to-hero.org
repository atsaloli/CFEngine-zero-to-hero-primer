#+Title: CFEngine Zero to Hero Primer
#+Author: Nick Anderson
#+Email: nick@cmdln.org
#+PROPERTY: header-args:cfengine3+ :eval never-export
#+PROPERTY: header-args:sh+ :eval never-export
#+PROPERTY: header-args:shell+ :eval never-export
#+REVEAL_ROOT: file:///home/nickanderson/src/reveal.js/
#+OPTIONS: reveal_center:t reveal_progress:t reveal_history:nil reveal_control:t
#+OPTIONS: reveal_rolling_links:t reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS: reveal_width:1200 reveal_height:800
#+OPTIOnS: reveal_single_file:t
# The TOC is a bit much for a slide show IMHO
#+OPTIONS: toc:nil tags:nil timestamp:nil
#+REVEAL_MARGIN: 0.1
#+REVEAL_MIN_SCALE: 0.5
#+REVEAL_MAX_SCALE: 2.5
# Available Transitions: default|cube|page|concave|zoom|linear|fade|none.
#+REVEAL_TRANS: fade
# Themes: Black (default) - White - League - Sky - Beige - Simple - Serif - Blood - Night - Moon - Solarized 
#+REVEAL_THEME: white 
# ?? Guess this flattens up to x levels deep
#+REVEAL_HLEVEL: 1
#+REVEAL_HEAD_PREAMBLE: <meta name=description" content=CFEngine Zero to Hero Primer.">
#+REVEAL_POSTAMBLE: <p> Created by Nick Anderson. </p>
#+REVEAL_PLUGINS: (markdown notes)
#+REVEAL_EXTRA_CSS: ./local.css
# Do not eval cfengine src blocks automatically on export
# THIS WORKED #+property: header-args :eval never-export


#+BEGIN_COMMENT
# Derived from [[http://github.com/bahamat/cf-primer][CF-Primer: Zero to Hero]]
# Brian Bennett <bahamat@digitalelf.net>, @bahamat
# Aleksey Tsalolikhin <aleksey@verticalsysadmin.com>

Copyright 2013 Brian Bennett, Nick Anderson

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
#+END_COMMENT

* Introduction
:PROPERTIES:
:ID:       bebd19ec-c478-4b8d-ad63-2216c814a5af
:END:

*CFEngine* contains a powerful language for controlling all aspects of a system.
CFEngine runs primarily on UNIX and UNIX-like operating systems, but can also
run on Windows.

** continued ...
CFEngine is very extensive and powerful. In this presentation you will learn
only a subset of what CFEngine can do. A mere tip of the iceberg, but this will
represent the bulk of what you do with CFEngine. In other words, you'll learn
the 20% of CFEngine that will do 80% of the work.

** Want to know more?

- [[http://verticalsysadmin.com/][Vertical Sysadmin's CFEngine courses]]
- [[https://docs.cfengine.com/lts/reference.html][CFEngine Reference Manual]]
- [[mailto:contact@cfengine.com][CFEngine Training & Professional Services]] (Email)
- [[http://shop.oreilly.com/product/110000787.do][Beyond Automation with CFEngine3]] (Video Training)

** Fork Me on Github!
:PROPERTIES:
:ID:       688caa3c-27be-483e-9c6b-9ce91134fea7
:END:

This presentation was made with love using org-mode 9.2.4, cfengine 3.12.2, and
reveal.js 3.8.0. You can get a copy of this presentation any time on Github.

<http://github.com/nickanderson/CFEngine-zero-to-hero-primer>

* CFEngine Components
:PROPERTIES:
:ID:       9a044a65-d73c-4727-8425-3d0dc14c7521
:END:

These are the major components of CFEngine that you will encounter on a day to
day basis.

- =cf-agent=
- =cf-execd=
- =cf-serverd=
- =cf-monitord=

** =cf-agent=
:PROPERTIES:
:ID:       171881f4-8e19-44dd-b6d1-5e52d64b59c7
:END:

=cf-agent= is the command you will use most often. It is used to run
policy(code) and ensure your system is in the desired state. If you are running
any CFEngine command from the command line, there's a greater than 99% chance
that this is it.

** =cf-execd=
:PROPERTIES:
:ID:       24db747a-4fcf-491c-ba39-f339f2730b8f
:END:

=cf-execd= is a periodic task scheduler. You can think of it like =cron= with an
understanding of CFEngine classes.

By default CFEngine runs and enforces policies every /five minutes/. =cf-execd=
is responsible for making that happen.

** =cf-serverd=
:PROPERTIES:
:ID:       1e211d18-0097-4ad4-a62c-0eb3e9984402
:END:

=cf-serverd= runs on the CFEngine server, as well as all clients.

- On servers it is responsible for serving files to clients.
- On clients it accepts =cf-runagent= requests
- In Enterprise it serves reports to queries from =cf-hub=

=cf-runagent= allows you to request ad-hoc policy runs. I rarely use it.

** =cf-monitord=
:PROPERTIES:
:ID:       c3cbe444-b1a2-490f-85cb-29d94152c0c9
:END:

=cf-monitord= monitors various statistics about the running system. This
information is made available in the form of *classes* and *variables*.

You'll almost never use =cf-monitord= directly. However the data provided by
=cf-monitord= is available to =cf-agent=.

*  
:PROPERTIES:
:ID:       d0330294-0334-4d64-97cd-fabe1c3ec6f3
:REVEAL_BACKGROUND: ./media/imperative-vs-declarative1_2016-05-11_16-31-47.png
:REVEAL_BACKGROUND_SIZE: 600px
:END:

** Imperative vs. Declarative
:PROPERTIES:
:ID:       a9547a43-da11-49a4-8640-3c6490415404
:END:

It is very likely that you have only ever used *imperative* languages. Examples
of imperative languages include C, Perl, Ruby, Python, shell scripting, etc.
Name a language. It's probably imperative.

CFEngine is a *declarative* language. The CFEngine language is merely a
/description/ of the final state. CFEngine uses *convergence* to arrive at the
described state.

*** Declarative Policy vs Imperative Script

#+BEGIN_EXAMPLE
  bundle agent main           | #!/bin/env/bash
  {                           |
    packages:                 |
                              |
      "openssh-server"        |
        policy => "present",  | yum install openssh-server
        version => "latest";  | yum upgrade openssh-server

  }
#+END_EXAMPLE

** Imperative is Sequential
:PROPERTIES:
:ID:       c828ad3f-79d0-42d4-9fc8-76d2348f8fa5
:END:

Imperative languages execute step by step in *sequence*.

- Goes in order from start to finish.
- If interrupted the state is /inconsistent/.
- Subsequent executions /typically/ repeat tasks already done.
  - Potentially causing damage.

For Example:
- Script appends line to file and restarts daemon.
- Second execution appends duplicate line and restarts daemon.
  - Daemon doesn't accept duplicate lines and service refuses to run.

*Imperative starts at known state A and transforms to known state B.*

** Declarative is Descriptive
:PROPERTIES:
:ID:       440944c7-b77e-427e-a263-c745fe75bac0
:END:

It is not a list of steps to achieve an outcome but a *description* of the
desired state. Because of this any deviation from the desired state can be
detected and corrected.

In other words, a declarative system can begin in /any/ state, not simply a
known state, and transform into the desired state.

Declarative states a list of things which must be true. It does not state how to
make them true.

When a system has reached the desired state it is said to have reached
*convergence*.

* Promise Theory
:PROPERTIES:
:ID:       9c0c5886-4b07-423e-9e4a-0b55a73515b7
:END:

Promise theory is the *fundamental underlying philosophy* that drives CFEngine.

It is a model of voluntary cooperation between individual, autonomous actors or
agents who publish their intentions to one another in the form of promises.

** What makes promises?
:PROPERTIES:
:ID:       200e380a-dd5d-4f0a-a36f-7734801183ba
:END:

A file (e.g., =/etc/apache2/httpd.conf=) can make promises about its own
contents, attributes, etc. But it does not make any promises about a process.

A process (e.g., =httpd=) can make a promise that it will be running. But it
does not make any promises about its configuration.

The configuration file and the process are /autonomous/. Each makes promises
about itself which cooperate toward an end.

** Going deeper
:PROPERTIES:
:ID:       4eda301f-e34c-4088-9c61-caee91158454
:END:

- [[https://www.youtube.com/playlist?list=PLYwRmweZvwB1C9HXvT4g6jXfZYET_cgXP][Promise Theory (animated video series)]]
  - [[https://www.youtube.com/watch?v=2TPsB5WuZgk&t=145s][Basic concepts]] (part 1)
  - [[https://www.youtube.com/watch?v=2E9s4gsIo_s][The rules of delegation]] (part 2)
  - [[https://www.youtube.com/watch?v=CZcWZokRRac][Scaling cooperation]] (part 3)
  - [[https://www.youtube.com/watch?v=shEL7lrYeoY][Scaling goals]] (part 4)

** Deeper still

- [[https://www.amazon.com/Thinking-Promises-Mark-Burgess-ebook/dp/B01092PYG8/ref=pd_cp_351_2?ie=UTF8&refRID=P8MMWZ7H2X6B52JEAHNB][Thinking in Promises]]
- [[https://www.amazon.com/Search-Certainty-Science-Information-Infrastructure-ebook/dp/B00WL6SPR6/ref=pd_sim_351_3?ie=UTF8&dpID=61EbYHkv7NL&dpSrc=sims&preST=_OU01_AC_UL160_SR107%252C160_&refRID=R1NF58A2W7Z570MN6V3P][In Search of Certainty]]
- [[https://www.amazon.com/Promise-Theory-Principles-Applications-1/dp/1495437779/][Promise Theory: Principals and Applicationcs]]

[[./media/thinking-in-promises-cover.jpg]] [[./media/in-search-of-certainty-cover.png]]

* Promises
:PROPERTIES:
:ID:       022f09e3-9cda-4e42-8ac5-754a1a42edac
:END:
** Anatomy of a Promise
:PROPERTIES:
:ID:       3f44af59-010c-4f53-9ffc-6ebbd10f99b7
:END:

#+BEGIN_SRC artist
  type:
    context::
      "promiser" -> "promisee"
                      ----------|
        attribute1 => "value",  |
        attribute2 => body;     |-- Promise Body
                      ----------|
#+END_SRC

- type :: is the kind of promise being made (e.g., files, commands, etc.).
- context :: Optional and defaults to =any::=. Promises with a context will only
             apply if the given context is true.
- promiser :: What is making the promise. (e.g., a file or a process).
- promisee :: An optional recipient or beneficiary of the promise.
- promise body :: is a collection of promise attributes (not to be confused with
                  a body used as an attribute value)

** Promise Attributes
:PROPERTIES:
:ID:       0a74a05e-a6e3-4ceb-9eed-7dd44ecc311d
:END:

- Separated by commas
- Vary by *promise type*
- Value is quoted string or unquoted object (function/body/bundle)

#+BEGIN_NOTES
  Each promise can have one or more attributes that describe the parameters of the
  promise. The available attributes will vary depending on the *promise type*.

  The value can be either a text string (which must be quoted) or another object
  (which must not be quoted). All of the attributes together are called the
  *promise body* of the promise (as in "the body of an e-mail", or "the body of a
  contract").

  When an attribute value is a body the body specified *must have a type matching
  the attribute name*.

  Attributes are separated by *commas*. Each promise ends with a *semicolon*.
#+END_NOTES

** Example Promise
:PROPERTIES:
:ID:       c87caf72-3377-4a84-9113-1b71a86ad340
:END:

#+BEGIN_SRC cfengine3 :exports both
  bundle agent main {
    files:
      linux::
        "/tmp/example" -> { "Instructor", "Students" }
          create => "true",
          touch => "true",
          action => warn_only;
  }
#+END_SRC

#+RESULTS:
:  warning: Need to touch (update time stamps) for '/tmp/multiple-attributes', but only a warning was promised!

#+BEGIN_NOTES
  - This is a promise of *type* =files=.
  - This promise has a *class context* of =linux= (it will only apply if running a
    Linux kernel).
  - The *promiser* is the POSIX path =/tmp/example=.
  - This promise has three *attribute*, specifying that the file should be
    created if it does not exist, it's timestamp should be updated, and only
    warn about what the agent would do.
  - The *promisee* is both of us
  - To create a directory instead, use a =files:= promise and append a =.= to the
    directory name (e.g., =/tmp/hello/.=)
#+END_NOTES

* Bundles
:PROPERTIES:
:ID:       52089c14-f3f9-44fa-9c78-665051e5454a
:END:

- collection of *promises*
- logical grouping
- can have parameters
- *ARE NOT FUNCTIONS*

** A bundle for Apache web-server might 

- ensure the =apache2= package is installed
- ensure the content in the config file is correct
- ensure content is present for serving
- ensure proper permissions of files
- ensure the =httpd= process is running
- ensure the =httpd= process is restarted when the configuration changes

** Anatomy of a Bundle
:PROPERTIES:
:ID:       c47adf7f-d46e-4b24-9069-3f6df29a9463
:END:

#+BEGIN_SRC cfengine3
  bundle type name
  {
      type:
        context::
          "promiser" -> { "promisee" }
            attribute1 => "value",
            attribute2 => value;

      type:
        context::
          "promiser" -> { "promisee" }
            attribute1 => "value",
            attribute2 => value;
  }
#+END_SRC

Bundles apply to the binary that executes them. E.g., =agent= bundles apply to
=cf-agent= while =server= bundles apply to =cf-serverd=.

Bundles of type =common= apply to any CFEngine binary.

** What component(s) use this bundle?
*** Example 1

#+BEGIN_SRC cfengine3
  bundle common globals
  {
    vars:

        "tool_path" string => "/srv/tools"
  }
#+END_SRC

#+BEGIN_NOTES
  - cf-agent, cf-monitord, cf-serverd
#+END_NOTES

*** Example 2

#+BEGIN_SRC cfengine3
  bundle server my_access_rules
  {
    access:

        "$(globals.tool_path)"
          admit_ips => { "192.168.0.0/24" };
  }
#+END_SRC

*** Example 3

#+BEGIN_SRC cfengine3
  bundle agent my_policy
  {
      
    vars:

      "config[PermitRootLogin]" string => "no";
      "config[Port]" string => "22";

    files:

        "/etc/ssh/sshd_config"
          edit_line => set_line_based( "my_policy.config", " ", "\s+", ".*", "\s*#\s*");
  }
#+END_SRC

*** Example 4

#+BEGIN_SRC cfengine3
  bundle monitor measure_cf_serverd
  {
    vars:

      "pid[cf-serverd]"
        string => readfile( "$(sys.piddir)/cf-serverd.pid", 4k );

      "reg_stat[rss]" string =>"(?:[^\s+]*\s+){23}([^\s]+)(?:.*)";

    measurements:

     "/proc/$(pid[cf-serverd])/stat"
       handle => "cf_serverd_vsize",
       stream_type => "file",
       data_type => "int",
       history_type => "weekly",
       units => "pages in memory",
       match_value => line_match_value(".*", $(reg_stat[rss]) );
  }
#+END_SRC


* Bodies
:PROPERTIES:
:ID:       a25471b9-fc26-4190-ad80-6fe557daf8f3
:END:

I stated before that the attributes of a promise, collectively, are called the
body. Depending on the specific attribute the value of an attribute can be an
*external body*.

A *body* is a collection of /attributes/. These are attributes that supplement
the promise.

** Anatomy of an external body
:PROPERTIES:
:ID:       9e437e47-6827-4813-b692-80212b7314e0
:END:

#+BEGIN_SRC cfengine3
  body TYPE NAME(OPTIONAL, PARAMS)
  {
          ATTRIBUTE => "value";
          ATTRIBUTEn => { "more", "values" };
  }
#+END_SRC

The difference between a /bundle/ and a /body/ is that a bundle contains
/promises/ while a /body/ contains only /attributes/.

*** Take a moment to let this sink in

- A *bundle* is a collection of /promises/.
- A *body* is a collection of /attributes/ that are applied to a promise.

The distinction is subtle, especially at first and many people are tripped up by
this.

In a body, each attribute ends with a *semicolon*.

(Note that in a bundle each promise ends with a *semicolon*, while attributes of
each promise are separated by *commas*)

** External body example

#+Caption: The m perms body takes one paramater
#+BEGIN_SRC cfengine3
  bundle agent main {
    files:
        "/tmp/file"
          perms => m(600);
  }
#+END_SRC

*** What is m?

*PRO TIP:* The [[https://github.com/cfengine/core/tree/master/contrib/cf-locate][=cf-locate=]] script in [[https://github.com/cfengine/core/tree/master/contrib/][core/contrib]] can help you find and view
body and bundle definitions within your policy set.

#+BEGIN_SRC shell :results output :exports both
  cf-locate -f "perms m\(.*"
#+END_SRC

#+RESULTS:
#+begin_example
-> body or bundle matching 'perms m\(.*' found in /home/nickanderson/.cfagent/inputs/lib/files.cf:1582
body perms m(mode)
# @brief Set the file mode
# @param mode The new mode
{
      mode   => "$(mode)";
}
#+end_example

* Abstraction and Re-usability
:PROPERTIES:
:ID:       f2c206eb-fd36-40f0-8f2b-0f390f0c5992
:END:

Bundles and bodies can be paramaterized for abstraction and re-usability. In
other words you can define one and call it even passing in parameters which will
implicitly become variables.

** Example
:PROPERTIES:
:ID:       0b8595fd-0ac5-43f6-a978-20babb7cb6ae
:END:

#+BEGIN_SRC cfengine3
  body type name (my_param) {
    attribute1 => "$(my_param)";
  }
#+END_SRC

The parameter =my_param= is accessed as a variable by =$(my_param)=.

* The Masterfiles Policy Framework
:PROPERTIES:
:ID:       a73ed34e-8f1a-49c2-b878-c3cef34c79ec
:END:

The *Masterfiles Policy Framework* is the default policy that ships with
CFEngine. The standard library is included.

- [[https://github.com/cfengine/masterfiles][Masterfiles Policy Framework]]

** CFEngine Standard Library
:PROPERTIES:
:ID:       66ce5ebc-f9a5-4a28-925f-d62220ca6eb3
:END:

The *CFEngine Standard Library* comes bundled with CFEngine in the
=masterfiles/lib/= directory.

The standard library contains ready to use bundles and bodies that you can
include in your promises and is growing with every version of CFEngine. Get to
know the standard library well, it will save you much time.

- [[https://docs.cfengine.com/lts/reference-masterfiles-policy-framework-lib.html][Standard Library Reference]]

* Putting it All together
:PROPERTIES:
:ID:       8906e180-eeea-4af5-ace5-fbcf093cf075
:END:

These are the building blocks. You now know what they all are.

* A few examples
:PROPERTIES:
:ID:       68586360-89e3-4971-9ecb-c99031283c8a
:END:

Now we will go through some examples.

I encourage you to try executing the examples as we go along.

- https://github.com/nickanderson/CFEngine-zero-to-hero-primer/tree/master/examples

** Executing the agent 

To execute a policy run the following command:

#+BEGIN_EXAMPLE
  $ cf-agent --inform --file ./test.cf --bundle bundlename
#+END_EXAMPLE

*Note:* Make sure you use the correct file and bundle name! For any examples
using a bundle named main you can skip specifying the bundle.

** Running commands
:PROPERTIES:
:ID:       f1a0a12d-213b-47b4-a76f-e90af704ed17
:END:

#+caption: =commands_echo_hello_world.cf=
#+BEGIN_SRC cfengine3 :tangle examples/commands_echo_hello_world.cf
  bundle agent main
  {
    commands:
        "/bin/echo Hello World!";
  }
#+END_SRC

#+BEGIN_NOTES
Commands are *not* the best way to accomplish automation.

- Can hide important details.
- Not the most efficient way to collect information.
#+END_NOTES

** Set File Permissions
:PROPERTIES:
:ID:       759fe7c4-fd50-4e0b-b9bb-0460d25c013f
:END:

#+caption: =set_file_permissions.cf=
#+BEGIN_SRC cfengine3 :tangle examples/set_file_permissions.cf
  bundle agent main {
    files:
      "/etc/shadow"     perms => perms_for_shadow_files;
      "/etc/gshadow"    perms => perms_for_shadow_files;
    reports: "Please run this policy as root" if => not( strcmp( "$(sys.user_data[gid]", "0" ) )); 
  }

  body perms perms_for_shadow_files {
    owners => { "root" };
    groups => { "root" };
    mode   => "0640";
  }
#+END_SRC

#+RESULTS:
#+begin_example
/home/nickanderson/src/presentations/CFEngine-zero-to-hero/cfengine3-22885Fvr:6:95: error: syntax error
  reports: "Please run this policy as root" if => not( strcmp( "$(sys.user_data[gid]", "0" ) )); 
                                                                                              ^
/home/nickanderson/src/presentations/CFEngine-zero-to-hero/cfengine3-22885Fvr:6:95: error: Check previous line, Expected ';', got ')'
  reports: "Please run this policy as root" if => not( strcmp( "$(sys.user_data[gid]", "0" ) )); 
                                                                                              ^
   error: There are syntax errors in policy files
   error: Policy failed validation with command '"/home/nickanderson/.cfagent/bin/cf-promises" -c "/home/nickanderson/src/presentations/CFEngine-zero-to-hero/cfengine3-22885Fvr"'
   error: CFEngine was not able to get confirmation of promises from cf-promises, so going to failsafe
   error: CFEngine failsafe.cf: /home/nickanderson/.cfagent/inputs /home/nickanderson/.cfagent/inputs/failsafe.cf
   error: No suitable server found
   error: No suitable server found
R: Built-in failsafe policy triggered
  notice: Q: ".../cf-agent" -f /":    error: Link '/usr/local/sbin/cf-key' points to '/var/cfengine/bin/cf-key' not '/home/nickanderson/.cfagent/bin/cf-key', error removing link
Q: ".../cf-agent" -f /":    error: Link '/usr/local/sbin/cf-agent' points to '/var/cfengine/bin/cf-agent' not '/home/nickanderson/.cfagent/bin/cf-agent', error removing link
Q: ".../cf-agent" -f /":    error: Link '/usr/local/sbin/cf-promises' points to '/var/cfengine/bin/cf-promises' not '/home/nickanderson/.cfagent/bin/cf-promises', error removing link
Q: ".../cf-agent" -f /":    error: Link '/usr/local/sbin/cf-runagent' points to '/var/cfengine/bin/cf-runagent' not '/home/nickanderson/.cfagent/bin/cf-runagent', error removing link
Q: ".../cf-agent" -f /":    error: Link '/usr/local/sbin/cf-monitord' points to '/var/cfengine/bin/cf-monitord' not '/home/nickanderson/.cfagent/bin/cf-monitord', error removing link
Q: ".../cf-agent" -f /":    error: Link '/usr/local/sbin/cf-serverd' points to '/var/cfengine/bin/cf-serverd' not '/home/nickanderson/.cfagent/bin/cf-serverd', error removing link
Q: ".../cf-agent" -f /":    error: No suitable server found
Q: ".../cf-agent" -f /":    error: No suitable server found
Q: ".../cf-agent" -f /":    error: No suitable server found
#+end_example

- This is an *agent* bundle (meaning that it is processed by =cf-agent=).
- Its purpose is to set the permissions on =/etc/shadow= and =/etc/gshadow=.
- It uses an external body named =perms_for_shadow_files=.
- The body only needs to be defined once and can be reused for any number of
  promises.

Note: The values for =owners= and =groups= is enclosed in curly braces. This is
because these attributes take a list of strings (aka, an =slist=).

** Copy an entire file
:PROPERTIES:
:ID:       4112e831-3a36-41f8-86df-6c0327623979
:END:

#+begin_src cfengine3
  bundle agent example {
    files:
      "/etc/motd"     copy_from => cp("/repo/motd");
  }

  body copy_from cp (from) {
    servers     => { "$(sys.policy_hub)" };
    source      => "$(from)";
    compare     => "digest";
  }
  bundle server my_access_rules
  {
    access:
      policy_server|am_policy_hub::
        "/repo"
          admit_ips => { "192.168.0.1/24" },
          admit_keys => { "SHA=12345" };
  }
#+end_src

#+BEGIN_NOTES
- The purpose of this policy is to copy =/etc/motd= from the CFEngine server
- =$(sys.policy_hub)= is an automatic variable which contains the CFEngine
  server's address.
- The path =/repo/motd= is on the /server's/ filesystem.
- The =compare= type tells CFEngine how to know when the file needs updating.
#+END_NOTES

*** Copy an entire file agent bundle

#+begin_src cfengine3
  bundle agent example {
    files:
      "/etc/motd"     copy_from => cp("/repo/motd");
  }
#+end_src

- The file =/etc/motd= should be a copy of a file described by the =cp=
  =copy_from= body.
  
*** Copy an entire file =copy_from= body

#+BEGIN_SRC cfengine3
  body copy_from cp (from) {
    servers     => { "$(sys.policy_hub)" };
    source      => "$(from)";
    compare     => "digest";
  }
#+END_SRC

- =source= :: The path to the file that should be copied.
- =servers= :: Servers which the file should be attempted to be copied from.
- =compare= :: How to determine if the file differs and requires update.

*** Copy an entire file =server= bundle

#+BEGIN_SRC cfengine3
  bundle server my_access_rules
  {
    access:
      policy_server|am_policy_hub::
        "/repo"
          admit_ips => { "192.168.0.1/24" },
          admit_keys => { "SHA=12345" };
  }
#+END_SRC

- =admit_ips= :: List of IPs or subnets that should be allowed to copy from
                 =/repo=.
- =admi_keys= :: List of cfengine ids that should be allowed to copy from
                 =/repo=.

** Edit a File
:PROPERTIES:
:ID:       df23c2a4-0fc9-492a-9587-b5ab168609c0
:END:

#+caption: =sshd_permit_root_login_no.cf=
#+BEGIN_SRC cfengine3 :tangle examples/sshd_permit_root_login_no.cf
  bundle agent main {
    files:
      "/etc/ssh/sshd_config"     edit_line => deny_root_ssh;
  }

  bundle edit_line deny_root_ssh {
    delete_lines:
      "^PermitRootLogin.*";
    insert_lines:
      "PermitRootLogin no";
  }
#+END_SRC

- This will delete any line matching the regular expression =^PermitRootLogin.*=.
- This also inserts the line =PermitRootLogin no= *at the end of the file*.
- Delete is always applied before insert, so it will not delete the inserted line.
- CFEngine is smart enough to know not to edit the file if the end result is
  already /converged/.
- This is an overly simplistic example. When editing configuration files you
  probably want to copy the whole file or use =set_config_values()= from the
  standard library.

* Variables

Can be one of several types:

- strings
- lists
- numbers
- data (JSON/YAML/CSV)

Reference: [[https://docs.cfengine.com/lts/reference-special-variables.html][Special Variables]], [[https://docs.cfengine.com/lts/reference-language-concepts-variables.html][Language Concepts -> Variables]], [[https://docs.cfengine.com/lts/reference-promise-types-vars.html][Promise Types and
Attributes -> vars]]

** Implicit iteration

CFEngine doesn't have for loops, but it implicitly iterates over lists and data
structure values.

#+Name: implicit-iteration
#+Caption: implicit-iteration.cf
#+BEGIN_SRC cfengine3 :tangle ./examples/list-iteration.cf :exports both
  bundle agent main
  {
    vars:
        "l" slist => { "two", "one", "three" };
        "d" data => '[ "three", "one", "two"]';
        "d2" data => '{ "one":"1", "two":"2", "three":"3"}';

    reports:
        "l contains $(l)";
        "d contains $(d)";
        "d2 contains $(d2)";
  }
#+END_SRC

*** Example output 

#+RESULTS: implicit-iteration
: R: l contains two
: R: l contains one
: R: l contains three
: R: d contains three
: R: d contains one
: R: d contains two
: R: d2 contains 1
: R: d2 contains 2
: R: d2 contains 3

** Data and arrays

#+Name: data-and-arrays.cf
#+Caption: data-and-arrays.cf
#+BEGIN_SRC cfengine3 :tangle ./examples/data-and-arrays.cf
  bundle agent main
  {
    vars:
        "d" data => '{ "key": { "subkey": "value" } }';

        "a[key][subkey]" string => "value";

    reports:
        "$(const.dollar)(d[key][subkey]) == $(d[key][subkey])";
        "$(const.dollar)(a[key][subkey]) == $(a[key][subkey])";
        "d contains$(const.n)$(with)" with => string_mustache( "{{%-top-}}", d );
        "a contains$(const.n)$(with)" with => string_mustache( "{{%-top-}}", a );
  }
#+END_SRC

*** Example Output

#+RESULTS: data-and-arrays.cf
#+begin_example
R: $(d[key][subkey]) == value
R: $(a[key][subkey]) == value
R: d contains
{
  "key": {
    "subkey": "value"
  }
}
R: a contains
{
  "key": {
    "subkey": "value"
  }
}
#+end_example

* Classification and Classes
:PROPERTIES:
:ID:       28958fde-5ec8-4305-bd03-6873bec81c3f
:END:

A *class* is like a tag (like tagging a photo). Classes are used to give a
promise *context*. Valid characters in classes are [A-Za-z0-9_] (alphanumeric
and underscores). There are two types of classes.

- *Built in classes*. These so called *hard classes* are classes that CFEngine
   will create automatically. Hard classes are determined based on the system
   attributes. For example a server running Linux will have the class =linux=.

- *User defined classes*. These so called *soft classes* are classes that are
   defined by you. You can create them based on the outcome of a promise, based
   on the existence of other classes, or for no reason.

** What classes are defined?
:PROPERTIES:
:ID:       813aca93-3777-49c0-9c6b-0ff1face8e5f
:END:

Use ~cf-promsies --show-classes~ to see the first order of resolved classes. 

#+Name: cf-promsies --show-classes
#+BEGIN_SRC sh :exports both :results raw :wrap EXAMPLE
  cf-promises --show-classes
#+END_SRC

*** sample cf-promises --show-classes output

#+BEGIN_EXAMPLE
Class name               Meta tags                               
4_cpus                   source=agent,derived-from=sys.cpus,hardclass
64_bit                   source=agent,hardclass                  
GMT_December             time_based,cfengine_internal_time_based_autoremove,source=agent,hardclass
Hr14                     time_based,cfengine_internal_time_based_autoremove,source=agent,hardclass
Min10_15                 time_based,cfengine_internal_time_based_autoremove,source=agent,hardclass
Yr2017                   time_based,cfengine_internal_time_based_autoremove,source=agent,hardclass
_stdlib_has_path_awk     source=promise                          
cfengine_3_11_0          inventory,attribute_name=none,source=agent,hardclass
ipv4_192_168_122_1       inventory,attribute_name=none,source=agent,hardclass
ipv4_gw_192_168_3_1      inventory,networking,/proc,source=agent,attribute_name=none,procfs,hardclass
mac_52_54_00_6b_62_06    inventory,attribute_name=none,source=agent,hardclass
ubuntu_17_10             inventory,attribute_name=none,source=agent,hardclass
#+END_EXAMPLE

** Control Promise Selection
:PROPERTIES:
:ID:       f702d707-312e-40b6-8bdd-967da8188cec
:END:

#+BEGIN_SRC cfengine3
  bundle agent apache_config {
    files:

      debian::
        "/etc/apache2/apache2.conf"
          copy_from => remote_cp("/cfengine/repo/debian/apache2.conf","$(sys.policy_hub)");
      redhat::
        "/etc/httpd/conf/httpd.conf"
          copy_from => remote_cp("/cfengine/repo/redhat/httpd.conf","$(sys.policy_hub)");
      solaris::
        "/etc/apache2/2.2/httpd.conf"
          copy_from => remote_cp("/cfengine/repo/solaris/httpd.conf","$(sys.policy_hub)");
  }
#+END_SRC

- Copy the appropriate config file for the given platform
- Promises outside of the specified context are skipped

** Promise Type and Class Context apply until they are reset
:PROPERTIES:
:ID:       5f448af0-c91c-4da9-bdbc-297979c5e110
:END:

#+caption: =implicit_class_context.cf=
#+BEGIN_SRC cfengine3 :tangle examples/implicit_class_context.cf
  bundle agent example {
    files:
      solaris::
        "/tmp/hello/world"
          create => "true";
        "/tmp/foo/bar"
          create => "true";
      linux::
        "/dev/shm/hello_world"
          create => "true";
    commands:
        "/bin/echo Hello World";
  }
#+END_SRC

- New class expression sets context for following promises
- New promise type resets context to =any= (implicit default)
 
#+BEGIN_NOTES
  The /promise type/ and /class context/ don't need to be listed for every
  promise. Think of each like a heading in an outline. Everything that follows is
  still under the same heading until a new heading is declared. If a new promise
  type is declared the class context is reset as well.
  
  The first three promises are of type =files=. The first two will only execute on
  =solaris= while the third will only execute on =linux=. The last promise has a
  new promise type, of =commands=, and will always execute. (Context is implicitly
  reset to =any::= when entering a new promise type.)
#+END_NOTES

** Classes are NOT nested

#+Name: There are no nested contexts
#+BEGIN_SRC cfengine3
  bundle agent main
  {
    reports:
        redhat:: # <- This context has no promises.
          64_bit:: # <- This context has one promise. (not additive)
            "I am $(sys.flavor) running on $(sys.arch)";
  }
#+END_SRC

- No promises are defined in the =redhat= context
- One promise is defined in the =64_bit= context
- Nesting class expressions does not make them additive

#+RESULTS: There are no nested contexts
: R: I am ubuntu_17 running on x86_64

** Use Classes to Control Flow
:PROPERTIES:
:ID:       f3ecf589-89b4-4a7b-aa3c-9fc68c710b07
:END:

#+BEGIN_SRC cfengine3
  bundle agent apache_config {
    commands:

      apache_config_repaired::
        "/usr/sbin/apache2ctl graceful";

    files:

      "/etc/apache2/apache2.conf"
          copy_from => remote_cp("/cfengine/repo/debian/apache2.conf","$(sys.policy_hub)")
          classes => results("bundle", "apache_config");

  }
#+END_SRC

- Only when the apache config is updated define =apache_config_repaired=.
- Only when =apache_config_repaired= is defined execute the command to restart
  the service.
  
I use this *ALL*. *THE*. *TIME*. If this class is to teach you 20% that
accomplishes 80%, *this slide* is the 5% that accomplishes 95%.

** Class Expressions
:PROPERTIES:
:ID:       b035d0a6-50e8-47c1-b688-3a07fc12c289
:END:

#+BEGIN_SRC cfengine3
  commands:
    apache_config_repaired.debian::
      "/usr/sbin/apache2ctl graceful";
    apache_config_reparied.redhat::
      "/usr/sbin/apachectl graceful";
#+END_SRC

|--------------+-------------------+-------------------------------------|
| Operator     | Meaning           | Example                             |
|--------------+-------------------+-------------------------------------|
| =.= and =&=  | boolean *and*     | =debian.Tuesday::=                  |
| =ǀ= and =ǀǀ=  | boolean *or*      | =TuesdayǀWednesday::=               |
| =!=          | boolean *not*     | =!Monday::=                         |
| =( )=        | Explicit grouping | =(debianǀredhat).!ubuntu.!centos::= |
|--------------+-------------------+-------------------------------------|

# Note the vertical pipes inside the table are actually unicode characters, this
# is just to make it work inside org-mode

** A Note About Classes and Distributions Based on Other Distributions
:PROPERTIES:
:ID:       d3e97cff-8043-4494-9735-7e5bb6d4ebb3
:END:

I said that only Debian systems will run =debian::= and only Red Hat will run
=redhat::=. This isn't exactly true.

- Ubuntu is based on Debian, and so will have both =ubuntu= and =debian= defined
  as hard classes.
- Likewise, CentOS is based on Red Hat and so will have both =centos= and
  =redhat= defined as hard classes.
- MPF defines =redat_pure= and =debian_pure=.

* Augments (=def.json=)

- Very early definition
- Loaded if =def.json= is found next to policy entry
- Classes based on system discovery (platform/networks/arch)
- Variables defined in =def= bundle scope

** Example augments

- Define =supported_platform= if the class =ubuntu_14=, =ubuntu_16=, or
  =ubuntu_17= is defined.
- Define =by_hostname= if the class =nickanderson_thinkpad_w550s= is defined.
 
#+Caption: =examples/augments/def.json=
#+BEGIN_SRC json :tangle ./examples/augments/def.json
  {
    "classes": {
        "supported_platform": [ "ubuntu_14", "ubuntu_16", "ubuntu_17" ],
        "by_hostname": [ "nickanderson_thinkpad_w550s" ]
    },
    "vars": {
        "myvar1": "defined from augments",
        "myvar2": "defined from augments"
      }
  }
#+END_SRC 

** Example policy using augments

#+Caption: =examples/augments/augments.cf=
#+BEGIN_SRC cfengine3 :tangle ./examples/augments/augments.cf
  bundle agent main
  {
    reports:
      "I defined '$(const.dollar)(def.myvar1)' as '$(def.myvar1)'";
      
      supported_platform::
        "This is a supported platform";

      by_hostname::
        "You can define classes from augments based on defined hostname";
  }
#+END_SRC

** Example output

#+BEGIN_SRC shell :results output
  chmod 600 ./examples/augments/augments.cf
  cf-agent -KIf ./examples/augments/augments.cf
#+END_SRC

#+RESULTS:
: R: I defined '$(def.myvar1)' as 'defined from augments'
: R: This is a supported platform
: R: You can define classes from augments based on defined hostname

** Policy always wins!

#+Caption: =examples/augments/augments-policy-wins.cf=
#+BEGIN_SRC cfengine3 :tangle ./examples/augments/augments-policy-wins.cf
  bundle common def
  {
    vars:
      "myvar1" string => "Defined in policy";
      "myvar2" string => "Defined in policy", if => not( isvariable( myvar2 ) );
  } 
  bundle agent main
  {
    reports:
      "I defined '$(const.dollar)(def.myvar1)' as '$(def.myvar1)'";
      "I defined '$(const.dollar)(def.myvar2)' as '$(def.myvar2)'";

      supported_platform::
        "This is a supported platform";

      by_hostname::
        "You can define classes from augments based on defined hostname";
  }
#+END_SRC

** Example output

#+BEGIN_SRC shell :results output
  chmod 600 ./examples/augments/augments-policy-wins.cf
  cf-agent -KIf ./examples/augments/augments-policy-wins.cf
#+END_SRC

#+RESULTS:
: R: I defined '$(def.myvar1)' as 'Defined in policy'
: R: I defined '$(def.myvar2)' as 'defined from augments'
: R: This is a supported platform
: R: You can define classes from augments based on defined hostname

** Multiple augments

... coming soon to an agent near you (3.12+)

* Managing Processes
:PROPERTIES:
:ID:       04dd5bb2-bad1-4efe-a2b3-bf34af6d465e
:END:
** Keep Services Running: Using Processes
:PROPERTIES:
:ID:       bb6290e8-213e-484d-b412-9382d1d785c3
:END:

#+BEGIN_SRC cfengine3
  bundle agent apache {

    processes:
        "apache2"
          restart_class => "StartApache";

    commands:
      StartApache::
        "/etc/init.d/apache2 start";
  }
#+END_SRC

This policy uses a =processes= promise to check the process table (with =ps=)
for the regular expression =.*apache2.*=. If it is not found then the class
=StartApache= will get defined.

When CFEngine executes =commands= promises Apache will be started.

** Ensuring Processes are Not Running: Using Processes and Commands
:PROPERTIES:
:ID:       bc4aa11f-fe91-4c70-b103-12fd4731be60
:END:

#+caption: =process_stop_bluetoothd.cf=
#+BEGIN_SRC cfengine3 :tangle examples/process_stop_bluetoothd.cf
  bundle agent stop_bluetooth {

    processes:

      "bluetoothd"
        process_stop => "/etc/init.d/bluetooth stop";
  }
#+END_SRC

This policy uses a =processes= promise to check the process table (with =ps=)
for the regular expression =.*bluetoothd.*=. If it is found the =process_stop=
command is executed.

** Ensuring Processes are Not Running: Using Processes and Signals
:PROPERTIES:
:ID:       7dfc7a39-30e0-4c63-b7ab-3a598cab3f7d
:END:

#+caption: =process_signals_bluetoothd.cf=
#+BEGIN_SRC cfengine3 :tangle examples/process_signals_bluetoothd.cf
  bundle agent stop_bluetooth {

    processes:

      "bluetoothd"
        signals => { "term", "kill" };
  }
#+END_SRC

This policy uses a =processes= promise to check the process table (with =ps=)
for the regular expression =.*bluetoothd.*=. Any matching process is sent the
=term= signal, then sent the =kill= signal.

*Note:* The promise =bluetoothd= becomes the *regular expression*,
=.*bluetoothd.*= that is matched against the output of =ps=. This means that it
can match *anywhere* on the line (in versions prior to 3.9), not just the
process name field. *Caveat emptor!*

** Keep Services Running: Using Services
:PROPERTIES:
:ID:       4e737c64-f5c6-41a6-b4c3-5a7c6082533c
:END:

#+BEGIN_SRC cfengine3
  bundle agent apache {
    services:

      "www"
        service_policy => "start";
  }
#+END_SRC

This uses the =services= promise type to ensure that Apache is always running.

The =standard_services= bundle implementation currently covers =systemd=,
=chkconfig=, the =service= command, =svcadm= and =systemV= init scripts. Proper
functionality relies on each installed service correctly implementing a service
check as appropriate for the init system in use.

** Ensuring Processes are Not Running: Using Services
:PROPERTIES:
:ID:       52325dac-802a-4a7c-a286-41167a4349d2
:END:

#+caption: =services_bluetoothd_stop.cf=
#+BEGIN_SRC cfengine3 :tangle examples/services_bluetoothd_stop.cf
  bundle agent stop_bluetoothd {
    services:

      "bluetoothd"
        service_policy => "stop";
  }
#+END_SRC

This policy uses a =services= promise type to ensure that Bluetooth services are
not running. Again, this only works for services that are defined under
=standard_services= in the standard library and requires cfengine 3.4.0 or
higher.

The same restrictions about distros apply to stopping services promises.

* Managing Packages
:PROPERTIES:
:ID:       640d1c4c-8e50-4924-9196-7d45ff2f495d
:END:

** Package Managers
:PROPERTIES:
:ID:       60949620-51bb-456e-8847-35e52d82a0ca
:END:

- =package_methods=

  =pip(flags)=, =npm(dir)=, =npm_g=, =brew(user)=, =apt=, =apt_get=,
  =apt_get_permissive=, =apt_get_release(release)=, =dpkg_version(repo)=,
  =rpm_version(repo)=, =windows_feature=, =msi_implicit(repo)=,
  =msi_explicit(repo)=, =yum=, =yum_rpm=, =yum_rpm_permissive=,
  =yum_rpm_enable_repo(repoid)=, =yum_group=, =rpm_filebased(path)=, =ips=,
  =smartos=, =smartos_pkg_add(repo)=, =opencsw=, =solaris(pkgname, spoolfile,
  adminfile)=, =solaris_install(adminfile)=, =freebsd=, =freebsd_portmaster=,
  =alpinelinux=, =emerge=, =pacman=, =zypper=, =generic=

- =package_modules=

  =yum=, =apt_get=, =freebsd_ports=, =nimclient=, =pkg=, =pkgsrc=

** New Implementation
:PROPERTIES:
:ID:       b3d20cf4-75cc-4a24-9188-d85c1b6f2be3
:END:

#+BEGIN_SRC cfengine3
  bundle agent install {
    packages:
      "zsh"
        policy  => "present",
        package_module  => yum,
        version => "latest";
  }
#+END_SRC

- The =policy= of =present= will make sure the package is installed on the
  system, while a =policy= of =absent= will ensure a package is not installed.
- The =package_module= of =yum= is included in the Masterfiles Policy Framework.
- The =version= of =latest= means the installed version should be the latest
  available. Alternatively you can provide an explicit version.

** Legacy Implementation
:PROPERTIES:
:ID:       a4a244f9-fa44-48ce-8585-8f15824b1712
:END:

#+BEGIN_SRC cfengine3
    bundle agent install {
      packages:
        "zsh"
          package_policy  => "addupdate",
          package_method  => apt,
          package_select  => ">=,
          package_version => "4.3.10-14";
    }
#+END_SRC

- The =package_policy= of =addupdate= will install or upgrade. Using =add=
  will only install, never upgrade, =upgrade= will upgrade only and =delete=
  will uninstall.
- The =package_method= of =apt= is in the standard library, look there for other
  package methods (e.g., rpm, ips, etc.).
- The =package_select= of =>== means the installed version must be equal to or
  newer than the specified version or it will be replaced. Using =<== would
  downgrade, if the =package_method= supports downgrading and ==== will
  require the exact version.

#+BEGIN_NOTES
Packages promises have be re-vamped with a new implementation that makes it
easier to dig into the specific details of how packages should be managed.
#+END_NOTES

* Managing Files
:PROPERTIES:
:ID:       84c4b634-81e2-4a05-ac60-b66f0224f360
:END:

** Methodologies

- Full file management
- Partial file management
 
** Templating a file
:PROPERTIES:
:ID:       6005b838-5e30-45f1-acfb-7de243839169
:END:

- [[http://mustache.github.io/][mustache]] :: Logic-less templating engine (*preferred*)
- [[https://docs.cfengine.com/lts/reference-promise-types-files.html#edit_template][cfengine]] :: CFEngine's original line based templating

*** Mustache Templating 

#+Caption: =template.mustache=
#+BEGIN_SRC text :tangle examples/template.mustache
  Hello from {{{vars.sys.fqhost}}}!

  {{#classes.linux}}I am a Linux Box!{{/classes.linux}}
  {{^classes.windows}}I am NOT a Windows Box{{/classes.windows}}
#+END_SRC

#+Caption: =template_file.cf=
#+BEGIN_SRC cfengine3 :tangle examples/template_file.cf
  bundle agent main{
    files:
        "/tmp/example"
          create => "true",
          edit_template => "$(this.promise_dirname)/template.mustache",
          template_method => "mustache";
  }
#+END_SRC

*** Mustache Extensions

- =-top-= :: Special key representing the complete data given to the templating
             engine.
- =@= :: Expands to the key that is currently iterating.
- =%= :: Variable prefix causing the data to be rendered as the multi-line JSON
         representation of the data given to the templating engine.
- =$= :: Variable prefix causing the data to be rendered as the serialized JSON
         representation of the data given to the templating engine.

*** Exercise: Render multiline JSON for =packagesmatching()=

=packagesmatching()= returns data. Render the multiline JSON representation of the data.

#+BEGIN_SRC cfengine3
  bundle agent main
  {
    vars:
        "p" data => packagesmatching( "emacs.*", ".*", ".*", ".*");

        "r" string => string_mustache( "{{%-top-}}", p ),
          if => not(isvariable( r ) );

    reports:
        "$(r)";

  }
#+END_SRC

#+RESULTS:
#+begin_example
R: [
  {
    "arch": "default",
    "method": "dpkg",
    "name": "emacsen-common",
    "version": "2.0.8"
  },
  {
    "arch": "default",
    "method": "dpkg",
    "name": "emacs24-common-non-dfsg",
    "version": "24.4+1-2"
  },
  {
    "arch": "default",
    "method": "dpkg",
    "name": "emacs24-common",
    "version": "24.5+1-1ubuntu2"
  },
  {
    "arch": "default",
    "method": "dpkg",
    "name": "emacs24-bin-common",
    "version": "24.5+1-1ubuntu2"
  },
  {
    "arch": "default",
    "method": "dpkg",
    "name": "emacs24",
    "version": "24.5+1-1ubuntu2"
  },
  {
    "arch": "default",
    "method": "dpkg",
    "name": "emacs",
    "version": "46.1"
  }
]
#+end_example

*** Mustache Tips

- Render raw values with ={{{VAR}}}= or ={{& VAR}}=. Mustache html escapes by
  default.

- Use =[[https://docs.cfengine.com/lts/reference-functions-string_mustache.html][string_mustache()]]= to render mustache into a string.

- =[[https://docs.cfengine.com/lts/reference-promise-types-files.html#template_data][template_data()]]= Helps to separate CFEngine specifics from templates.

#+BEGIN_NOTES
  - Watch out for html escaped values
  - =template_method => "inline_mustache"= coming in future release
  - Separating cfengine specifics from templates can ease offloading templates
    and data to external agents.
#+END_NOTES 

** Deleting a file
:PROPERTIES:
:ID:       dcde8434-d578-4bd2-9798-390bab27d97b
:END:

#+BEGIN_SRC cfengine3
  bundle agent tidy {
    files:
      "/var/log/.*"
        file_select => days_old("7"),
        delete => tidy;
  }
#+END_SRC

This policy will delete any files in =/var/log/= older than 7 days. The
=days_old()= and =tidy= bodies are included in the standard library,

To delete a file indiscriminately, omit the =file_select=.

Look up [[https://docs.cfengine.com/lts/reference-promise-types-files.html#file_select][=file_select=]] and [[https://docs.cfengine.com/lts/reference-masterfiles-policy-framework-lib-files.html#tidy][=tidy=]] in the [[https://docs.cfengine.com/lts/reference.html][reference-manual]] to find more ways to
use this.

* Troubleshooting

** Which hub am I bootstrapped to?

- ~cat /var/cfengine/policy_server.dat~
- ~cf-promises --show-vars | grep sys.policy_hub~

** Is cfengine running?

- ~ps -ef | grep [c]f-~

You should expect to find =cf-execd=, =cf-serverd=, and =cf-monitord= on all
hosts. Additional processes will be seen on Enterprise Hubs

** When did the agent last run?

- ~ls -lh /var/cfengine/promise_summary.log~

** Review output from previous agent runs

- ~ls /var/cfengine/outputs~
- ~cat /var/cfengine/outputs/previous~

** Manual report collection from Enterprise Hub

- ~cf-hub --hail <IP|HOSTNAME> --verbose --query rebase~
- ~cf-hub -H <IP|HOSTNAME> -v -q delta~

*** Unspecified server refusal

#+BEGIN_EXAMPLE
  [root@hub ~]# cf-hub -H 10.10.10.11 -q rebase
     error: Abort transmission: got " Unspecified server refusal (see verbose server output)" from 10.10.10.11
#+END_EXAMPLE

- Usually indicates the host does not trust the hub.
- Is the host bootstrapped to the hub you expect?

*** =SSL_read=: receive timeout 

#+BEGIN_EXAMPLE
  [root@hub ~]# cf-hub -q rebase -H 10.10.10.11
     error: SSL_read: receive timeout
#+END_EXAMPLE

- The report data is not able to be collected before =cf-hub= times out.
- Run the agent on the remote host and define =cfe_internal_purge_reports= e.g.
  ~cf-agent --no-lock --define cfe_internal_purge_reports~.

*** Connection refused

- Firewall blocking inbound connections on port =5308=
- =cf-serverd= not running on remote host
 
* Setting Up a Client/Server Environment                           :noexport:
:PROPERTIES:
:ID:       66515861-4365-48d4-9658-6a9788eddc67
:END:

Before starting you need to have cfengine installed on the server and the client
and the server FQDN must be set properly in DNS (or use the IP addresses). This
is ideally handled by your provisioning process. Along with automating server
function you should also be automating your provisioning process.

Some ways of automating provisioning are [[http://fedoraproject.org][kickstart]], [[http://wiki.debian.org/DebianInstaller/Preseed][preseed]], [[http://wiki.debian.org/FAI][fai]], [[http://cobbler.github.io/][cobbler]], [[http://www.osalt.com/g4u][disk
imaging]], [[http://aws.amazon.com/ec2/][instance cloning]], etc, etc. This, of course, is not a complete list.

** Bootstraping the Server and Client
:PROPERTIES:
:ID:       19be29ca-f7a2-4e00-8bfe-0c82abcf5587
:END:

*** Server Side
:PROPERTIES:
:ID:       2f62e0b9-1c3b-413e-9b7b-7be933cd09cb
:END:

Edit =/var/cfengine/masterfiles/def.cf= to set the =acl= list for the IP
addresses of your network, then run:

#+BEGIN_EXAMPLE
  cf-agent --bootstrap $(hostname --fqdn)
  cf-agent -KI
#+END_EXAMPLE

*** Client Side
:PROPERTIES:
:ID:       54a6c47a-fad0-4850-9e41-2fae90482477
:END:

Simply run:

#+BEGIN_EXAMPLE
  cf-agent --bootstrap server.fqdn.example.com
#+END_EXAMPLE

You can use the server's IP address instead of the DNS name.

** Managing and Distributing Policies
:PROPERTIES:
:ID:       d9e383b1-66ce-4c83-9bc1-249ba4d388b3
:END:

The policy files are in =/var/cfengine/masterfiles= on the server (also known as
the =policy_hub=) and are copied to =/var/cfengine/inputs=. All clients then
copy =/var/cfengine/inputs= from the server.

Now edit the policy in =/var/cfengine/masterfiles= on the server and watch for
the changes to happen on the client.

As you write new policies, each bundle needs to be listed in the
=bundlesequence= and each file needs to be listed in =inputs=. Both of these are
under =body common control= inside of =promises.cf=.

Bundles are executed in the order they are listed in the =bundlesequence=, but
=inputs= can be listed in any order.

* Reporting on Promise Outcomes
:PROPERTIES:
:ID:       aeed71b0-6fb3-4012-b33d-d8e5d6e345e8
:END:

CFEngine logs to =/var/cfengine/promise_summary.log=. Here's an example log message:

#+BEGIN_EXAMPLE
  1463018982,1463018990: Outcome of version CFEngine Promises.cf 3.7.0 (agent-0):\
   Promises observed - Total promise compliance: 93% kept, 3% repaired,\ 4% not kept (out of 148 events).\
   User promise compliance: 93% kept, 2% repaired, 5% not kept (out of 130 events).
   CFEngine system compliance: 94% kept, 6% repaired, 0% not kept (out of 18 events).
#+END_EXAMPLE

*Note:* The timestamp is a Unix epoch.

CFEngine will also send an email to the configured address in =body executor
control== any time there is output from an agent run that differed from the
previous run.

And finally you can use the =-I= flag to have CFEngine *inform* you of repairs.
(Shown here along with the =-K= flag which ignores any lock timers).

#+BEGIN_EXAMPLE
  cf-agent -KI
#+END_EXAMPLE

*** CFEngine Core/Community
**** The verbose agent log

Running the agent in verbose mode ( ~cf-agent --verbose~ | ~cf-agent -v~ )
provides all of the details about each promise and its result

#+BEGIN_SRC cfengine3 :tangle /tmp/example.cf
  bundle agent main
  {

    files:

        "/tmp/example"
          handle => "example_file_exists_and_contains_date",
          create => "true",
          edit_line => lines_present( $(sys.date) );
  }

  bundle edit_line lines_present(lines)
  # @brief Ensure `lines` are present in the file. Lines that do not exist are appended to the file
  # @param List or string that should be present in the file
  #
  # **Example:**
  #
  # ```cf3
  # bundle agent example
  # {
  #  vars:
  #    "nameservers" slist => { "8.8.8.8", "8.8.4.4" };
  #
  #  files:
  #      "/etc/resolv.conf" edit_line => lines_present( @(nameservers) );
  #      "/etc/ssh/sshd_config" edit_line => lines_present( "PermitRootLogin no" );
  # }
  # ```
  {
    insert_lines:

        "$(lines)"
          comment => "Append lines if they don't exist";
  }
#+END_SRC

In the verbose output as each promise is actuated a =BEGIN promsie= is emitted
with the promise handle or filename and line number position if it does not have
a handle. In the example output we can see that the promise for =/tmp/example=
was =REPAIRED=.

#+RESULTS:
#+BEGIN_EXAMPLE
 verbose: B: *****************************************************************
 verbose: B: BEGIN bundle main
 verbose: B: *****************************************************************
 verbose: P: .........................................................
 verbose: P: BEGIN promise 'example_file_exists_and_contains_date' of type "files" (pass 1)
 verbose: P:    Promiser/affected object: '/tmp/example'
 verbose: P:    Part of bundle: main
 verbose: P:    Base context class: any
 verbose: P:    Stack path: /default/main/files/'/tmp/example'[1]
 verbose: Using literal pathtype for '/tmp/example'
 verbose: No mode was set, choose plain file default 0600
    info: Created file '/tmp/example', mode 0600
 verbose: Handling file edits in edit_line bundle 'lines_present'
 verbose: V:     +  Private parameter: 'lines' in scope 'lines_present' (type: s) in pass 1
 verbose: P: .........................................................
 verbose: P: BEGIN promise 'promise_example_cf_32' of type "insert_lines" (pass 1)
 verbose: P:    Promiser/affected object: 'Mon Dec  4 21:08:38 2017'
 verbose: P:    Part of bundle: lines_present
 verbose: P:    Base context class: any
 verbose: P:    Stack path: /default/main/files/'/tmp/example'/default/lines_present/insert_lines/'Mon Dec  4 21:08:38 2017'[1]
 verbose: P:
 verbose: P:    Comment:  Append lines if they don't exist
 verbose: Additional promise info: source path './example.cf' at line 32 comment 'Append lines if they don't exist'
 verbose: Inserting the promised line 'Mon Dec  4 21:08:38 2017' into '/tmp/example' after locator
 verbose: P: .........................................................
 verbose: P: BEGIN promise 'promise_example_cf_32' of type "insert_lines" (pass 1)
 verbose: P:    Promiser/affected object: 'Mon Dec  4 21:08:38 2017'
 verbose: P:    Part of bundle: lines_present
 verbose: P:    Base context class: any
 verbose: P:    Stack path: /default/main/files/'/tmp/example'/default/lines_present/insert_lines/'Mon Dec  4 21:08:38 2017'[1]
 verbose: P:
 verbose: P:    Comment:  Append lines if they don't exist
 verbose: P: .........................................................
 verbose: P: BEGIN promise 'promise_example_cf_32' of type "insert_lines" (pass 1)
 verbose: P:    Promiser/affected object: 'Mon Dec  4 21:08:38 2017'
 verbose: P:    Part of bundle: lines_present
 verbose: P:    Base context class: any
 verbose: P:    Stack path: /default/main/files/'/tmp/example'/default/lines_present/insert_lines/'Mon Dec  4 21:08:38 2017'[1]
 verbose: P:
 verbose: P:    Comment:  Append lines if they don't exist
    info: Edit file '/tmp/example'
 verbose: Handling file existence constraints on '/tmp/example'
 verbose: A: Promise REPAIRED
 verbose: P: END files promise (/tmp/example)
 verbose: P: .........................................................
 verbose: P: BEGIN promise 'example_file_exists_and_contains_date' of type "files" (pass 2)
 verbose: P:    Promiser/affected object: '/tmp/example'
 verbose: P:    Part of bundle: main
 verbose: P:    Base context class: any
 verbose: P:    Stack path: /default/main/files/'/tmp/example'[1]
 verbose: Using literal pathtype for '/tmp/example'
 verbose: P: .........................................................
 verbose: P: BEGIN promise 'example_file_exists_and_contains_date' of type "files" (pass 3)
 verbose: P:    Promiser/affected object: '/tmp/example'
 verbose: P:    Part of bundle: main
 verbose: P:    Base context class: any
 verbose: P:    Stack path: /default/main/files/'/tmp/example'[1]
 verbose: Using literal pathtype for '/tmp/example'
 verbose: A: ...................................................
 verbose: A: Bundle Accounting Summary for 'main' in namespace default
 verbose: A: Promises kept in 'main' = 0
 verbose: A: Promises not kept in 'main' = 0
 verbose: A: Promises repaired in 'main' = 2
 verbose: A: Aggregate compliance (promises kept/repaired) for bundle 'main' = 100.0%
 verbose: A: ...................................................
 verbose: B: *****************************************************************
 verbose: B: END bundle main
 verbose: B: *****************************************************************
 verbose: Generate diff state reports for policy './example.cf' SKIPPED
 verbose: No lock purging scheduled
 verbose: Outcome of version (not specified) (agent-0): Promises observed - Total promise compliance: 0% kept, 100% repaired, 0% not kept (out of 2 events). User promise compliance: 0% kept, 100% repaired, 0% not kept (out of 2 events). CFEngine system compliance: 0% kept, 0% repaired, 0% not kept (out of 0 events).
#+END_EXAMPLE

**** Promise logging

Promises can be configured to [[https://docs.cfengine.com/lts/reference-promise-types.html#log_repaired][log their outcomes]] to a file with =log_kept=,
=log_repaired=, and =log_failed= attributes in an action body.

#+BEGIN_SRC cfengine3
  bundle agent main
  {
    commands:
        "/bin/true"
          action => log_my_repairs( '/tmp/repaired.log' );

    reports:
        "/tmp/repaired.log"
          printfile => cat( $(this.promiser) );
  }

  body action log_my_repairs( file )
  {
        log_repaired => "$(file)";
        log_string => "$(sys.date) REPAIRED $(this.promiser)";
  }
#+END_SRC

#+RESULTS:
: R: /tmp/repaired.log
: R: Mon Dec  4 21:21:38 2017 REPAIRED /bin/true

*** CFEngine Enterprise

CFEngine enterprise provides details logging without special configuration.

**** Changes UI

The changes reporting interface is the easiest way to what repairs the agent is
making to your infrastructure.

#+DOWNLOADED: file:///home/nickanderson/Pictures/Screenshots/2017-12-04_Selection_001.png @ 2017-12-04 22:04:51
[[file:./media/changes-ui.png]]

**** Changes API

Changes can also be queried from the [[https://docs.cfengine.com/lts/reference-enterprise-api-ref-changes.html][changes rest api]]. Here we query for repairs made
by =files= type promises.
#+BEGIN_EXAMPLE
  [root@hub ~]# curl https://hub/api/v2/changes/policy?promisetype=files
  {
      "data": [
          {
              "bundlename": "cfe_internal_update_policy",
              "changetime": 1512427971,
              "hostkey": "SHA=01fe75e93ca88bbd381eb720e9b43d0840ea8727aae8fc84391c297c42798f5c",
              "hostname": "hub",
              "logmessages": [
                  "Copying from 'localhost:/var/cfengine/masterfiles/cf_promises_release_id'"
              ],
              "policyfile": "/var/cfengine/inputs/cfe_internal/update/update_policy.cf",
              "promisees": [],
              "promisehandle": "cfe_internal_update_policy_files_inputs_dir",
              "promiser": "/var/cfengine/inputs",
              "promisetype": "files",
              "stackpath": "/default/cfe_internal_update_policy/files/'/var/cfengine/inputs'[1]"
          },
          {
              "bundlename": "cfe_internal_setup_knowledge",
              "changetime": 1512428912,
              "hostkey": "SHA=01fe75e93ca88bbd381eb720e9b43d0840ea8727aae8fc84391c297c42798f5c",
              "hostname": "hub",
              "logmessages": [
                  "Owner of '/var/cfengine/httpd/htdocs/application/logs/./log-2017-12-04.log' was 0, setting to 497",
                  "Group of '/var/cfengine/httpd/htdocs/application/logs/./log-2017-12-04.log' was 0, setting to 497",
                  "Object '/var/cfengine/httpd/htdocs/application/logs/./log-2017-12-04.log' had permission 0644, changed it to 0640"
              ],
              "policyfile": "/var/cfengine/inputs/cfe_internal/enterprise/CFE_knowledge.cf",
              "promisees": [],
              "promisehandle": "cfe_internal_setup_knowledge_files_doc_root_application_logs",
              "promiser": "/var/cfengine/httpd/htdocs/application/logs/.",
              "promisetype": "files",
              "stackpath": "/default/cfe_internal_management/methods/'CFEngine_Internals'/default/cfe_internal_enterprise_main/methods/'hub'/default/cfe_internal_setup_knowledge/files/'/var/cfengine/httpd/htdocs/application/logs/.'[1]"
          }
      ],
      "total": 2,
      "next": null,
      "previous": null
  }
#+END_EXAMPLE

See Also: [[https://docs.cfengine.com/lts/examples-enterprise-api-examples-changes-api-usage.html][query rest api]]

**** Custom Reports and Query API

The custom reports interface and associated [[https://docs.cfengine.com/lts/reference-enterprise-api-ref-query.html][query rest api]] allow more flexible
reports to be run.

Queries can be made against the =promiselog= table. This query finds the
promises that are repaired the most excluding internal cfengine related promises
and promises from the stdlib.

#+BEGIN_SRC sql
  -- Find most frequently repaired promises excluding lib and cfe_internal directories
  SELECT namespace,bundlename,promisetype,promisehandle, promiser, count(promiseoutcome)
  AS count
  FROM promiselog
  WHERE promiseoutcome = 'REPAIRED'
  AND policyfile
  NOT ilike '%/lib/%'
  AND policyfile
  NOT ilike '%cfe_internal%'
  GROUP BY namespace, bundlename, promisetype,promisehandle,promiser
  ORDER BY count DESC
#+END_SRC
  
Reference: [[https://docs.cfengine.com/docs/3.10/examples-enterprise-api-examples-sql-queries.html][query api examples]]

**** /var/cfengine/state/promise_log/*.csv

*WARNING:* These logs are purged upon collection by the hub.

In Enterprise 3.7 each agent run logs to a CSV file named for the time the agent
started in =$(sys.workdir)/state/promise_log/=.

The fields are =promise hash=, =policy file=, =release id=, unknown (waiting on
developer feedback), =namespace=, =bundle=, =promise type=, =stack path= (call
tree), =promise handle=, =promisees=, =log messages=

#+BEGIN_SRC text
  719b756d3dc8fd7bdd20284c1fd894ae40bac55d8790855b074159db8fe187ae,/var/cfengine/inputs/cfe_internal/enterprise/CFE_hub_specific.cf,<unknown-release-id>,114,default,cfe_internal_update_folders,files,/var/cfengine/master_software_updates/windows_i686,/default/cfe_internal_management/methods/'CFEngine_Internals'/default/cfe_internal_enterprise_main/methods/'hub'/default/cfe_internal_update_folders/files/'/var/cfengine/master_software_updates/windows_i686'[40],cfe_internal_update_folders_files_create_dirs,"[""goal_updated""]","[""Created directory '/var/cfengine/master_software_updates/windows_i686/.'""]"
#+END_SRC

**** promise_log.jsonl

*WARNING:* These logs are purged upon collection by the hub.

Beginning with Enterprise 3.9 we began logging promise outcomes to a JSON format
in =$(sys.statedir)/promise_log.jsonl=.

Each promise outcome is logged along with the bundle name, promise handle, log
messages near the promise actuation, the promise namespace, policy filename,
promise hash, promise type, promisees, promiser, release id, stack path (call
path), and the timestamp of the agent ran.

Here is an example of the output:

#+Caption: promise_log.jsonl
#+Name: promise_log.jsonl
#+BEGIN_SRC json
  {
      "execution": {
          "bundle":"file_make_mustache",
          "handle":"",
          "log_messages":[
              "Created file '/var/cfengine/httpd/conf/httpd.conf.staged', mode 0600",
              "Updated rendering of '/var/cfengine/httpd/conf/httpd.conf.staged' from mustache template '/var/cfengine/inputs/cfe_internal/enterprise/templates/httpd.conf.mustache'"
          ],
          "namespace":"default",
          "policy_filename":"/var/cfengine/inputs/lib/files.cf",
          "promise_hash":"ebc3dce615bcdb724e53a9761a24f2e7ed4f2e01aed1ce85dc217a9d3429fed7",
          "promise_outcome":"REPAIRED",
          "promise_type":"files",
          "promisees":[
              "CFEngine Enterprise",
              "Mission Portal"],
          "promiser":"/var/cfengine/httpd/conf/httpd.conf.staged",
          "release_id":"<unknown-release-id>",
          "stack_path":"/default/cfe_internal_management/methods/'CFEngine_Internals'/default/cfe_internal_enterprise_mission_portal/methods/'Apache Configuration'/default/cfe_internal_enterprise_mission_portal_apache/methods/'Stage Apache Config'/default/file_make_mustache/files/'/var/cfengine/httpd/conf/httpd.conf.staged'[0]"
      },
      "timestamp":1470326639
  },
  {
      "execution":{
          "bundle":"mission_portal_apache_from_stage",
          "handle":"",
          "log_messages":[
              "Updated '/var/cfengine/httpd/conf/httpd.conf' from source '/var/cfengine/httpd/conf/httpd.conf.staged' on 'localhost'"
          ],
          "namespace":"default",
          "policy_filename":"/var/cfengine/inputs/cfe_internal/enterprise/mission_portal.cf",
          "promise_hash":"d730f2911834395411e4f3168847fc6cc522955f97652de41e02c8bc15f3f761",
          "promise_outcome":"REPAIRED",
          "promise_type":"files",
          "promisees":[
              "CFEngine Enterprise",
              "Mission Portal"
          ],
          "promiser":"/var/cfengine/httpd/conf/httpd.conf",
          "release_id":"<unknown-release-id>",
          "stack_path":"/default/cfe_internal_management/methods/'CFEngine_Internals'/default/cfe_internal_enterprise_mission_portal/methods/'Apache Configuration'/default/cfe_internal_enterprise_mission_portal_apache/methods/'Manage Final Apache Config'/default/mission_portal_apache_from_stage/files/'/var/cfengine/httpd/conf/httpd.conf'[0]"
      },
      "timestamp":1470326639
  }
#+END_SRC

** Debugging
:PROPERTIES:
:ID:       1e36c971-9bc8-43f8-814b-d6ab8f3c8bcf
:END:

Inevitably, something will go wrong, and you will need to dig deep to figure
something out. Lucky for you, I have some tips for debugging.

*** Run without locks
:PROPERTIES:
:ID:       f86345f4-8990-4310-94bd-c08edbb32ee9
:END:

 Again, using =-K= to disable locks is useful.

*** Using Verbose Mode
:PROPERTIES:
:ID:       e4c6cdd2-7113-4b53-b1ca-614afde6c415
:END:

CFEngine's verbose output can be fantastic for debugging. Use the =-v= flag to
turn it on.

#+BEGIN_SRC sh :results raw :exports both :wrap EXAMPLE
  cf-agent -Kv | grep -A 5 "BEGIN bundle"
#+END_SRC

When viewing =verbose= output, look for =BUNDLE <name>= for the bundle that you
suspect is having trouble.

#+RESULTS:
#+BEGIN_EXAMPLE
  verbose: B: BEGIN bundle main
  verbose: B: *****************************************************************
  verbose: P: .........................................................
  verbose: P: BEGIN promise 'promise_promises_cf_4' of type "reports" (pass 1)
  verbose: P:    Promiser/affected object: 'Hello World!'
  verbose: P:    Part of bundle: main
#+END_EXAMPLE

CFEngine will tell you exactly what is going on with each promise, in
excruciating detail.

#+BEGIN_EXAMPLE
  verbose: Using literal pathtype for '/tmp/touch'
  verbose: No mode was set, choose plain file default 0600
     info: Created file '/tmp/touch', mode 0600
  verbose: Handling file existence constraints on '/tmp/touch'
  verbose: A: Promise REPAIRED
  verbose: P: END files promise (/tmp/touch...)
#+END_EXAMPLE

*** Comments
:PROPERTIES:
:ID:       f70a691d-3f41-4b38-999e-f2a9b203872d
:END:

CFEngine supports /comments/ as part of its data structure. Every promise can
have a =comment= attribute whose value is a quoted text string.

#+BEGIN_SRC cfengine3
  bundle agent example {
    files:
      "/etc/bind/named.cache"
        copy_from => scp("$(def.files)/bind/named.cache"),
        comment   => "More recent copy of named.cache than shipped with bind";
  }
#+END_SRC

Comments show up in the verbose output.

#+BEGIN_EXAMPLE
  verbose: P:    Container path : '/default/main/files/'/etc/bind/named.cache'[0]'
  verbose: P:
  verbose: P:    Comment:  More recent copy of named.cache than shipped with bind.
  verbose: P: .........................................................
#+END_EXAMPLE

The comment should always be *why* the promise is being made. Up until now none
of the examples have used comments to save space on the slide. When writing your
policies for real *every* promise should have a meaningful comment.

You'll thank me when this saves the day.

#+BEGIN_NOTES
Think about why this promise is important to the proper functioning of your infrastructure.
- What could go wrong if this promise isn't kept
#+END_NOTES

*** Promise Handles
:PROPERTIES:
:ID:       0100492d-e829-45d5-ad86-18c0097418b3
:END:

When debugging, promise /handles/ are also useful. Again, every promise can have
a =handle= attribute whose value is a quoted canonical string.

#+BEGIN_SRC cfengine3
  bundle agent example{
    files:
      "/etc/bind/named.cache"
        copy_from => scp("$(def.files)/bind/named.cache"),
        handle    => "update_etc_bind_named_cache",
        comment   => "More recent copy of named.cache than shipped with bind";
  }
#+END_SRC

CFEngine will tell you the handle of each promise in the verbose output.

#+BEGIN_EXAMPLE
  verbose: P: BEGIN promise 'update_etc_bind_named_cache' of type "files" (pass 1)
  verbose: P:    Promiser/affected object: '/etc/bind/named.cache'
  verbose: P:    Part of bundle: example
  verbose: P:    Base context class: any
#+END_EXAMPLE

By giving each promise a unique handle you can swiftly jump back and forth
between your debug output and your policy file. When writing your policies for
real *every* promise should have a unique handle.

You'll thank me when this saves the day.

#+BEGIN_NOTES

CFEngine Enterprise will automatically assign handles to each promise in the
form
=promise_$(this.promise_dirname)/$(this.promise_filename)_$(promise.line_number)=.

I believe this will come into core in 3.9 or 3.10.
@jimis?

#+END_NOTES

*** Promisees
:PROPERTIES:
:ID:       1fac9d2a-357d-41b4-9363-d7be3ec437d6
:END:

When debugging, promise /stakeholders/ aka /promisees/ are useful for
understanding [[https://github.com/nickanderson/cfengine-inventory_users_last_login/commit/cd2fb3454cf362efa5621e39800984c1d7ad655e][who cares]] about a given promise.

#+BEGIN_SRC cfengine3
  bundle agent example {
    files:
      "/etc/bind/named.cache" -> { "Operations", "Nick Anderson" }
        copy_from => scp("$(def.files)/bind/named.cache"),
        handle    => "update_etc_bind_named_cache",
        comment   => "More recent copy of named.cache than shipped with bind";
  }
#+END_SRC

CFEngine will tell you additional info about each promise.

#+BEGIN_EXAMPLE
  verbose: Additional promise info: handle 'update_etc_bind_named_cache'\
           source path './t.cf' at line 4 promisee  {'Operations','Nick Anderson'}\
           comment 'More recent copy of named.cache than shipped with bind.'
#+END_EXAMPLE

*** Meta
:PROPERTIES:
:ID:       ae9c713c-e3be-4b07-bd88-056bbc1af431
:END:

When debugging variables and classes promise /meta/ data is useful to help
identify variables and classes with specific attributes.

#+caption: =debugging_classes_and_vars_with_tags.cf=
#+BEGIN_SRC cfengine3 :tangle examples/debugging_classes_and_vars_with_tags.cf
  bundle agent main{
    classes:
        "my_class" expression => "any", meta => { "mytag" };
    vars:
        "my_var" string => "value", meta => { "mytag" };
        "my_vars" slist => variablesmatching(".*", "mytag" );
        "my_classes" slist => classesmatching(".*", "mytag" );
    reports:
        "My var: $(my_vars)";
        "My class: $(my_classes)";
  }
#+END_SRC

*Note:* Promise meta data is not currently displayed in the CFEngine's verbose
output.

* The Rest
:PROPERTIES:
:ID:       d42914dc-b51d-46cd-b254-8f0e7e12b0fa
:END:

Here's a list of topics that I didn't cover. This is to give you a taste of the
rest of the power that is behind CFEngine. Dig deeper by checking them out in
the [[https://docs.cfengine.com/lts/reference.html][reference manual]].

- =vars:= promises — Varables, strings, integers and reals (and lists of each).
- =methods:= promises — Create a self-contained bundle that can be called like a
  function.
- =storage:= promises — For local or remote (NFS) filesystems.
- =edit_xml:= promises - Promise by path, CFEngine does the XML for you.
- Monitoring — Using data from =cf-monitor=.

** Pro Tips
:PROPERTIES:
:ID:       f9326762-bccd-47d5-b431-dbdddd021822
:END:

- /Don't edit the standard library/. Create a =site_lib.cf= and add your custom
  library bundles and bodies there. This helps with upgrading because you won't
  have to patch your changes into the new version of the library. When you feel
  a bundle or body is ready for public use you can submit it to CFEngine by
  opening a pull request on [[http://github.com/cfengine/masterfiles][Github]].
- /Make built-in classes and user defined classes easy to distinguish by sight./
  CFEngine creates hard classes =all_lower_case_separated_by_underscores=.
  Whenever I define classes myself I use =CamelCase=.
- /Not sure how to organize =masterfiles=?/
  - [[https://digitalelf.net/2013/04/a-case-study-in-cfengine-layout/][A Case Study in CFEngine Layout]] by Brian Bennett.
  - [[https://github.com/nickanderson/example-a10042][Example a10042]]
- /Use =git=/ to revision control =masterfiles=.
- /Syntax errors?/ Only read the very first error. Fix it, then try again. A
  missing character in one promise will throw the whole file off.
- Checkout the [[https://docs.cfengine.com/lts/guide-language-concepts-augments.html][Augments file]]
- Checkout [[https://stedolan.github.io/jq/][jq]] (because you can use it with [[https://docs.cfengine.com/docs/3.9/reference-functions-mapdata.html][mapdata()]] in 3.9+)
- Read the [[https://docs.cfengine.com/lts/reference.html][reference manual]] (all of it)

*** Magic in CFEngine
:LOGBOOK:
CLOCK: [2017-09-28 Thu 18:39]--[2017-09-28 Thu 18:48] =>  0:09
:END:

**** If I try to define a class with an illegal class character there is no error

For example:

#+BEGIN_SRC cfengine3 :exports both 
  bundle agent main
  {
    classes:
    
      "my-illegal-class";
      
    reports:
      "$(with)" with => join( " ", classesmatching( "my.illegal.class" ) );

  }
#+END_SRC

#+RESULTS:
: R: my_illegal_class

The agent assumes you intended to canonify the string in the spirit of auto
correction it canonifies it for you.

This courtesy is not extended when checking classes. You must explicitly
canonify your string when using it in a class expression.

For example: 

#+BEGIN_SRC cfengine3 :exports both 
  bundle agent main
  {
    vars:
    
      "hostname" string => "$(sys.uqhost)";
    
    reports:
    
      any::
      
        "$(hostname) contains invalid class characters";
        "The class expression containing a nonvalid character is not a valid class expression";
        "The agent silently skips the section"; 
      
      "$(hostname)"::
        "hello";
        
      any::
      
        "See that explicit canonification works";
        "Hi"
          if => canonify( $(hostname) );
  }
  
#+END_SRC

#+RESULTS:
: R: nickanderson-thinkpad-w550s contains invalid class characters
: R: The class expression containing a nonvalid character is not a valid class expression
: R: The agent silently skips the section
: R: See that explicit canonification works
: R: Hi

**** When I promise a directory is 600 it gets set to 700

For example: 

#+BEGIN_SRC cfengine3
  bundle agent main
  {
    files:
      "/tmp/dir/."
        create => "true",
        perms => m(600);
        
   vars:
     "mode" string => filestat( "/tmp/dir", permoct );
     
     reports:
       "/tmp/dir mode is $(with)" with => filestat( "/tmp/dir", permoct );
     
  }
#+END_SRC

#+RESULTS:
: R: /tmp/dir mode is 700

This is configurable behavior but by default if you promise a directory should
be readable (list the files within the directory) the agent assumes that you
also meant for it to be executable so that it can be entered and access the file
and directories inside.
     
To disable the feature set [[https://docs.cfengine.com/lts/reference-promise-types-files.html#rxdirs][rxdirs]] to =false= in the =perms= body you are
using.

For example:

#+BEGIN_SRC cfengine3
  bundle agent main
  {
    files:
      "/tmp/dir/."
        create => "true",
        perms => my_m_norxdir(600);
        
   vars:
     "mode" string => filestat( "/tmp/dir", permoct );
     
     reports:
       "/tmp/dir mode is $(with)" with => filestat( "/tmp/dir", permoct );
  }
  
  body perms my_m_norxdir(mode)
  {
    rxdirs => "false";
    inherit_from => m( $(mode) ); # body inheritance available since 3.8.0
  }
#+END_SRC

#+RESULTS:
: R: /tmp/dir mode is 600

* Thanks
:PROPERTIES:
:ID:       a2fc6d66-53af-437a-99cd-db190f54580b
:END:
* Todos :noexport:
:PROPERTIES:
:ID:       f313ffe6-4543-48a3-bff8-26784f3acfce
:END:

How not to cfengine
commands:
 
    redhat.64_bit::
     " cd /etc;if grep '10.135.130.11\|10.135.130.12\|10.135.128.11\|10.135.128.12' /etc/resolv.conf; then /bin/sed -i 's/10.135.130.11/10.135.139.11/;s/10.135.130.12/10.135.139.12/;s/10.135.128.11/10.135.139.11/;s/10.135.128.12/10.135.139.12/' /etc/resolv.conf ; service network restart; fi"
        contain => in_shell;
